# python_tools/generate_scripts_init_list.py
import os
import re

SCRIPT_ROOT = "src/Sandbox/TestProject/Assets/Scripts"
OUTPUT_CPP = "src/Sandbox/TestProject/Generated/ScriptInitList.cpp"
OUTPUT_HEADER = "src/Sandbox/TestProject/Generated/ScriptIncludes.h"

SCRIPT_CLASS_REGEX = re.compile(r'class\s+(\w+)\s*:\s*public\s+Salix::CppScript')

def normalize(name): return name.replace('_', '').lower()

def find_script_classes():
    scripts = {}  # {class_name: (header_path, cpp_path_or_None)}

    print(f"\nüîç Starting script scan in: {SCRIPT_ROOT}")
    print("\nüîé [Pass 1] Scanning header files for script declarations...\n")

    for root, _, files in os.walk(SCRIPT_ROOT):
        print(f"üìÇ Entering: {root}")
        cpp_files = {normalize(f[:-4]): os.path.join(root, f) for f in files if f.endswith(".cpp")}

        for file in files:
            if file.endswith((".h", ".hpp")):
                full_path = os.path.join(root, file)
                print(f"   üìÑ Checking header: {file}")
                try:
                    with open(full_path, "r", encoding="utf-8") as f:
                        content = f.read()
                        matches = SCRIPT_CLASS_REGEX.findall(content)
                        for class_name in matches:
                            norm = normalize(class_name)
                            cpp_path = cpp_files.get(norm)
                            if cpp_path:
                                print(f"     ‚úÖ Found script: {class_name} (matched .cpp: {os.path.relpath(cpp_path)})")
                            else:
                                print(f"     ‚ö†Ô∏è  Found script '{class_name}', but no matching .cpp found")
                            scripts[class_name] = (full_path, cpp_path)
                except Exception as e:
                    print(f"     ‚ùå Failed to read {file}: {e}")
    return scripts

def generate_script_includes(scripts):
    os.makedirs(os.path.dirname(OUTPUT_HEADER), exist_ok=True)
    with open(OUTPUT_HEADER, "w", encoding="utf-8") as f:
        f.write("// Auto-generated by generate_script_init_list.py\n")
        f.write("#pragma once\n\n")
        f.write("// Includes for all CppScript headers\n")
        for class_name, (header_path, _) in sorted(scripts.items()):
            rel_path = os.path.relpath(header_path, os.path.dirname(OUTPUT_HEADER)).replace("\\", "/")
            f.write(f'#include "{rel_path}"\n')
    print(f"‚úÖ Generated: {OUTPUT_HEADER}")

def generate_script_init_list(scripts):
    os.makedirs(os.path.dirname(OUTPUT_CPP), exist_ok=True)
    with open(OUTPUT_CPP, "w", encoding="utf-8") as f:
        f.write("// Auto-generated by generate_script_init_list.py\n")
        f.write('#include "ScriptIncludes.h"\n')
        f.write("#include <cereal/types/polymorphic.hpp>\n")
        f.write("#include <Salix/scripting/ScriptFactory.h>\n\n")

        f.write('extern "C" __declspec(dllexport)\n')
        f.write("void register_all_scripts() {\n")

        for class_name in sorted(scripts.keys()):
            f.write(f"    ::cereal::RegisterType<{class_name}>();\n")
            f.write(f"    ::cereal::registerPolymorphicRelation<Salix::CppScript, {class_name}>();\n")
            f.write(f"    Salix::ScriptFactory::get().register_script(\"{class_name}\", []() {{ return std::make_unique<{class_name}>(); }});\n\n")

        f.write("}\n")

    print(f"‚úÖ Generated: {OUTPUT_CPP}")

def main():
    scripts = find_script_classes()
    if not scripts:
        print("‚ö†Ô∏è  No CppScript classes found.")
        return

    print(f"\nüîß Total scripts found: {len(scripts)}")
    generate_script_includes(scripts)
    generate_script_init_list(scripts)

if __name__ == "__main__":
    main()
